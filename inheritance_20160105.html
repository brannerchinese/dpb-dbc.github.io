<!DOCTYPE html>
<html>
  <head>
    <!-- Template from https://github.com/gnab/remark, 20151228 -->
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Inheritance
## David Branner, Dev Bootcamp
### 20160105

---

# What these slides cover

 1. Inheritance

 1. Overriding methods

 1. Chaining methods

 1. Things to remember about `super`

 1. Terminology Review

---

## Inheritance
--

When you subclass (inherit from another class), like this:
--

```ruby
class NewClass < OldClass
```
--

you are making the statement "`NewClass` is a kind of `OldClass`". 
--

**It's a statement of identity.**
--


When you make `PearTree` class that inherits from the `FruitTree` class, you are saying that a `PearTree` is a type of `FruitTree`. 
--


When you make a `Fruit` class that does _not_ inherit from the `FruitTree` class, you are saying that a `Fruit` is not a type of `FruitTree`, although you are leaving open the possibility that an instance of `FruitTree` may contain one or more instances of `Fruit`. 
--


Object-Oriented Programming (OOP) is a way of modeling things and ideas from the real world in the virtual world. Inheritance is a key element of that.


In contrast, when you `include` a module, it is like packing a toolset in your toolbox — you are not making a statement about the identity of your toolbox; you're just adding tools.

---

## Inheritance, cont'd
--


When you subclass you get all the methods and attributes of the superclass (parent class), as well as all of its methods and attributes, all the way up to the parent of all parents, `Object`.
--


If you want to add your own methods and attributes to your new class, you will have those in addition to all the inherited ones.
--


Technically speaking, attributes aren't inherited, only methods. But in practice, it doesn't make any difference because attributes that are defined in any inherited methods will be initialized when the subclass is instantiated.
--


If you like, you can replace ("override") inherited methods or modify them.

---

## Overriding methods
--

Here is an example of overriding — we subclass `Array` and change the `to_s` method to give us a surprise. First, look at the normal behavior of `Array.to_s`:
--

```ruby
[1] pry(main)> [1, 2, 3].to_s
=> "[1, 2, 3]"
```
--

Now proceed:
--

```ruby
[2] pry(main)> class NewArray < Array
[2] pry(main)*   def to_s
[2] pry(main)*     'surprise!'
[2] pry(main)*   end  
[2] pry(main)* end  
=> :to_s
```
--

Test it in action:
--

```ruby
[3] pry(main)> n = NewArray.new([1, 2, 3])
=> [1, 2, 3]
[4] pry(main)> n.to_s
=> "surprise!"
```

---

## Overriding methods, cont'd
--


If your class's immediate parent doesn't have the method (or attribute) you want to use, Ruby will follow "method lookup" (or "method name resolution"), looking gradually up the chain of inheritance — class to superclass — until it finds a method with the correct name.
--


The immediate parent class doesn't have to have a method with the name you are looking for — all that matters is that some superclass up the chain of subclassing has it.
--

The class nearest to your class is the one whose method will be used.

---

## Chaining methods
--

If you want to inherit a method but add some functionality to it, that is called "chaining".
--


Chaining is done with the `super` keyword. That postpones inheriting the superclass's version of the method until the moment `super` appears. Example:
--

```ruby
[1] pry(main)> class NewArray < Array
[1] pry(main)*   def to_s  
[1] pry(main)*     puts 'first, surprise! afterwards...'    
[1] pry(main)*     super    
[1] pry(main)*   end    
[1] pry(main)* end  
=> :to_s
```

Now try it out:
--

```ruby
[2] pry(main)> n = NewArray.new([1, 2, 3])
=> [1, 2, 3]
[3] pry(main)> n.to_s
first, surprise! afterwards...
=> "[1, 2, 3]"
```

---

## Things to remember about `super`
--


1. You don't need `super` unless you want to make changes to a method you are inheriting. 
--


   Inheritance already gives you all the methods, complete, that exist in the chain of inheritance.
--


   If the only line of code you have in a method is `super`, it's unnecessary.
--


1. `super` can be used with any method or methods.
--


   There is no limit to the number of methods you can use it on in a given class.
--


1. In practice, you will often see `super` used in the `initialize` method (the "constructor"), to individualize the details of the subclass somewhat before (or after) constructing the instance following the model of the superclass.
--


1. If the method takes arguments, `super` takes those arguments, too.

<!-- qqq TODO: composition -->
<!-- qqq TODO: making private method public -->
<!-- qqq TODO: order of method-declaration doesn't matter -->

<!-- qqq

composition: making modules and classes more modular — serving a more narrowly defined purpose — and then "composing" (combining) their functionality in the larger program


MVC: Most of what we used to consider the program goes into the Model. We separate out the Viewer (user interface), and we create a Controller to communicate between the Model and the Viewer. The viewer doesn't do any processing. Can have multiple views. The Model is stripped of all user-interaction.

public vs. private vs. protected

-->

---

## Terminology Review

 1. **subclass** class X
--
: to make a new class that inherits from class X
--


 1. **superclass**
--
: parent class
--


 1. **`Object`**
--
: the ulimate parent of all classes
--


 1. **override** a method
--
: to replace (entirely) an inherited method
--


 1. **OOP**
--
: object-oriented programming
--


 1. **chaining**
--
: partially overriding a method but also inheriting the rest of it, using `super`
--


 1. **method lookup**
--

 (also "method name resolution")
--
: procedure for determining the definition of a method 
--
_at the moment it is to be executed_ (rather than when the code is parsed)
--


 1. **constructor**
--
: the `initialize` method, which actually brings into being an instance of the class

---

class: center, middle

## END

    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>

<!-- From http://joshbode.github.io/remark/ansi.html#3, 20151229 -->
    <script src="http://gnab.github.io/remark/downloads/remark-latest.min.js"></script>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <script type="text/javascript">
      var hljs = remark.highlighter.engine;
    </script>
    <script src="terminal.language.js" type="text/javascript"></script>
    <script type="text/javascript">
      var slideshow = remark.create({
        highlightStyle: 'solarized_dark'
      });
      // extract the embedded styling from ansi spans
      $('code.terminal > span.hljs-ansi').replaceWith(function(i, x) {
        return x.replace(/<(\/?(\w+).*?)>/g, '<$1>')
      });
    </script>
  </body>
</html>

[end]