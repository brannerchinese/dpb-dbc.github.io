<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <!-- Style below adapted from view-source:http://gnab.github.io/remark/
          20160116 -->
    <style>
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif);
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
        font-family: 'Droid Serif';
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .remark-slide-content h1 { font-size: 3em; }
      .remark-slide-content h2 { font-size: 2em; }
      .remark-slide-content h3 { font-size: 1.6em; }
      .footnote {
        position: absolute;
        bottom: 3em;
      }
      li p { line-height: 1.25em; }
      .red { color: #fa0000; }
      .large { font-size: 2em; }
      a, a > code {
        color: rgb(249, 38, 114);
        text-decoration: none;
      }
      code {
        background: #e7e8e2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      #slideshow .slide .content code {
        font-size: 0.8em;
      }
      #slideshow .slide .content pre code {
        font-size: 0.9em;
        padding: 15px;
      }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      /* Slide-specific styling */
      #slide-inverse .footnote {
        bottom: 12px;
        left: 20px;
      }
      #slide-how .slides {
        font-size: 0.9em;
        position: absolute;
        top:  151px;
        right: 140px;
      }
      #slide-how .slides h3 {
        margin-top: 0.2em;
      }
      #slide-how .slides .first, #slide-how .slides .second {
        padding: 1px 20px;
        height: 90px;
        width: 120px;
        -moz-box-shadow: 0 0 10px #777;
        -webkit-box-shadow: 0 0 10px #777;
        box-shadow: 0 0 10px #777;
      }
      #slide-how .slides .first {
        background: #fff;
        position: absolute;
        top: 20%;
        left: 20%;
        z-index: 1;
      }
      #slide-how .slides .second {
        position: relative;
        background: #fff;
        z-index: 0;
      }

      /* Two-column layout */
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
        .left-column h2:last-of-type, .left-column h3:last-child {
          color: #000;
        }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 1em;
      }
    </style>

  </head>
  <body>
    <textarea id="source">

class: center, middle

# Modules and Classes
## David Branner, Dev Bootcamp
### 20160104

---

## Differences between a module and a class
--


(Both are ways of fostering **code reuse** and **modularization**.)
--


 1. State (modifiable data)
--


 1. How to use
--


 1. Naming
--


 1. Terminology Review
--


**Jargon warning** 
--
— There is a lot of special terminology ahead.

---

## State
--


"State" means any stored information (data).
--


In practice, it means especially data that can be modified, in contrast to constants, which cannot.
--


(Constants conventionally have their names capitalized in Ruby.)
--


Differences between modules and classes with respect to state:
--

 1. A module provides methods and constants.
--

 1. A class provides methods, constants, and **state**.
--


State is stored in the form of "attributes", of which there are different kinds. 
--

Normally we are talking about "instance attributes", which are marked with a single `@` before the variable-name.
--


An instance attribute may need to have "setter" and "getter" methods. 
--

You assign values to it with the setter; you access its value with the getter.


---

In practice, you will use this syntax most of the time:
--

```ruby
class MyClass
  attr_reader :for_getter              # Can only read, not write.
  attr_writer :for_setter              # Can only write, not read.
  attr_accessor :for_setter_and_getter # Can both read and write.

  def initialize(for_setter_and_getter, for_setter, for_getter)
    @for_setter_and_getter = for_setter_and_getter
    @for_setter = for_setter           # Can only be accessed within class.
    @for_getter = for_getter           # Can only be changed within class.
  end
end
```
--

Accessing the three different kinds of attributes we just defined:
--

```ruby
[2] pry(main)> m = MyClass.new('first', 'second', 'third')
=> #<MyClass:0x007fb230a13800
 @for_getter="third",
 @for_setter="second",
 @for_setter_and_getter="first">
[3] pry(main)> m.for_setter_and_getter
=> "first"
[4] pry(main)> m.for_setter
NoMethodError: undefined method `for_setter' for #<MyClass:0x007fb230a13800>
Did you mean?  for_setter=
               for_getter
from (pry):18:in `__pry__'
[5] pry(main)> m.for_getter
=> "third"
```

---

Note that there _is_ a way to access an attribute marked as `attr_writer`: 
--

write a method to do it — that's allowed, because it's happening within the class.
--


Here's an example of using a `to_s` to _display_ an `attr_writer` attribute (without actually returning it, though of course you could do that, too):
--

```ruby
class MyClass
  attr_writer :for_setter              # Can only write, not read.

  def initialize(for_setter)
    @for_setter = for_setter           # Can only be accessed within class.
  end

  def to_s                             # Convenient way of displaying this.
     'for_setter: ' + @for_setter
  end
end
```
--

In actual use:
--

```ruby
[1] pry(main)> m = MyClass.new('second')
=> #<MyClass:0x007fc5d1918478 @for_setter="second">
[2] pry(main)> m.for_setter
NoMethodError: undefined method `for_setter' for #<MyClass:0x007fc5d1918478 @for_setter="second">
from (pry):25:in `__pry__'
[3] pry(main)> m.to_s
=> "for_setter: second"
```

---

## Using a module or class
--


 1. A module is "mixed in", using `include`. 
--
 Any number of modules may be mixed in to a single program, 
--
(or function, or module, or class).
--

    ```ruby
    include MyModule
    include AnotherModule
    include FurtherModule
    ...
    ```
--

 1. A class is "instantiated" as an "instance", using `new`. 
--
The class is a blueprint; the instance is one particular case made from the blueprint.
--

    ```ruby
    a = Array.new
    ```
--

    Here `a` is one particular instance of the class `Array`.
--

 1. A class "inherits from" another class. 
--

(This is a big subject, to which we will return another day.)
--
 
    ```ruby
    class MyClass < parent_class
    ```
--
    
    A class can only have one direct parent.

---

## Naming modules and classes
--

Both classes and modules are capitalized and use `CamelCase`. 
--
(Functions and methods are lower-case and use `snake_case`.)

 1. Modules are conventionally named as adjectives, and tend to end in `-able`. 
--


    To remind yourself, two modules in the standard library are `Enumerable` and `Comparable`. 
--

 1. Classes are usually named as nouns, because each is an object. 
--


    Everything in Ruby is an object 
--
(including the program itself). 
--


    But, in practice, most of the time you'll find that an object is normally an instance of some class.

---

## Terminology Review

 1. **state**
--
: any stored information (data)
--


 1. **constant**
--
: data that will never need to be modified
--


 1. **attribute**
--
: state belonging to an object
--


 1. **instance**
--
: an object constructed by some particular class
--


 1. **instantiate**
--
: to construct an object
--


 1. **object**
--
: an instance of some class; more generally, a location in memory containing data or functionality
--


 1. **setter**
--
: a kind of method that assigns data to an attribute
--


 1. **getter method**
--
: a kind of method that retrieves data stored in an attribute
--


 1. **`attr_writer`**
--
: an attribute for which a setter but not a getter is allowed
--


 1. **`attr_reader`**
--
: an attribute for which a getter but not a setter is allowed
--


 1. **`attr_accessor`**
--
: an attribute for which both setter and getter are allowed

---

class: center, middle

## END

    </textarea>
    <!-- Scripts below adapted from view-source:http://gnab.github.io/remark/
          20160116 -->

    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"></script>
    <script>
      var hljs = remark.highlighter.engine;
    </script>
    <script src="https://gnab.github.io/remark/remark.language.js"></script>
    <!-- Original highlightStyle on Remark site: monokai 
         Similar:                tomorrow-night arta
         DPB also likes:         idea zenburn sunburst ascetic github
         Very blue:              far 
         Apparently not working: rainbow solarized_light solarized_dark
                                 vs -->
    <script>
      var slideshow = remark.create({
          highlightStyle: 'zenburn',
          highlightLanguage: 'remark',
          highlightLines: true
        }) ;
    </script>
  </body>
</html>
