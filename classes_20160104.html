<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Modules and Classes
## David Branner, Dev Bootcamp
### 20160104

---

## Differences between a module and a class
--


(Both are ways of fostering **code reuse** and **modularization**.)
--


 1. State (modifiable data)
--


 1. How to use
--


 1. Naming
--


**Jargon warning** 
--
— There is a lot of special terminology ahead.

---

## State
--


"State" means any stored information (data).
--


In practice, it means especially data that can be modified, in contrast to constants, which cannot.
--


(Constants conventionally have their names capitalized in Ruby.)
--


Differences between modules and classes with respect to state:
--

 1. A module provides methods and constants.
--

 1. A class provides methods, constants, and **state**.
--


State is stored in the form of "attributes", of which there are different kinds. 
--

Normally we are talking about "instance attributes", which are marked with a single `@` before the variable-name.
--


An instance attribute may need to have "setter" and "getter" methods. 
--

You assign values to it with the setter; you access its value with the getter.


---

In practice, you will use this syntax most of the time:
--

```ruby
class MyClass
  attr_reader :for_getter              # Can only read, not write.
  attr_writer :for_setter              # Can only write, not read.
  attr_accessor :for_setter_and_getter # Can both read and write.

  def initialize(for_setter_and_getter, for_setter, for_getter)
    @for_setter_and_getter = for_setter_and_getter
    @for_setter = for_setter           # Can only be accessed within class.
    @for_getter = for_getter           # Can only be changed within class.
  end
end
```
--

Accessing the three different kinds of attributes we just defined:
--

```ruby
[2] pry(main)> m = MyClass.new('first', 'second', 'third')
=> #<MyClass:0x007fb230a13800
 @for_getter="third",
 @for_setter="second",
 @for_setter_and_getter="first">
[3] pry(main)> m.for_setter_and_getter
=> "first"
[4] pry(main)> m.for_setter
NoMethodError: undefined method `for_setter' for #<MyClass:0x007fb230a13800>
Did you mean?  for_setter=
               for_getter
from (pry):18:in `__pry__'
[5] pry(main)> m.for_getter
=> "third"
```

---

Note that there _is_ a way to access an attribute marked as `attr_writer`: 
--

write a method to do it — that's allowed, because it's happening within the class.
--


Here's an example of using a `to_s` to _display_ an `attr_writer` attribute (without actually returning it, though of course you could do that, too):
--

```ruby
class MyClass
  attr_writer :for_setter              # Can only write, not read.

  def initialize(for_setter)
    @for_setter = for_setter           # Can only be accessed within class.
  end

  def to_s                             # Convenient way of displaying this.
     'for_setter: ' + @for_setter
  end
end
```
--

In actual use:
--

```ruby
[1] pry(main)> m = MyClass.new('second')
=> #<MyClass:0x007fc5d1918478 @for_setter="second">
[2] pry(main)> m.for_setter
NoMethodError: undefined method `for_setter' for #<MyClass:0x007fc5d1918478 @for_setter="second">
from (pry):25:in `__pry__'
[3] pry(main)> m.to_s
=> "for_setter: second"
```

---

## Using a module or class
--


 1. A module is "mixed in", using `include`. 
--
 Any number of modules may be mixed in to a single program, 
--
(or function, or module, or class).
--

    ```ruby
    include MyModule
    include AnotherModule
    include FurtherModule
    ...
    ```
--

 1. A class is "instantiated" as an "instance", using `new`. 
--
The class is a blueprint; the instance is one particular case made from the blueprint.
--

    ```ruby
    a = Array.new
    ```
--

    Here `a` is one particular instance of the class `Array`.
--

 1. A class "inherits from" another class. 
--

(This is a big subject, to which we will return another day.)
--
 
    ```ruby
    class MyClass < parent_class
    ```
--
    
    A class can only have one direct parent.

---

## Naming modules and classes
--

Both classes and modules are capitalized and use `CamelCase`. 
--
(Functions and methods are lower-case and use `snake_case`.)

 1. Modules are conventionally named as adjectives, and tend to end in `-able`. 
--


    To remind yourself, two modules in the standard library are `Enumerable` and `Comparable`. 
--

 1. Classes are usually named as nouns, because each is an object. 
--


    Everything in Ruby is an object 
--
(including the program itself). 
--


    But, in practice, most of the time you'll find that an object is normally an instance of some class.

---

## Terminology Review

 1. **state**
--
: any stored information (data)

 1. **constant**
--
: data that will never need to be modified

 1. **attribute**
--
: state belonging to an object

 1. **instance**
--
: an object constructed by some particular class

 1. **instantiate**
--
: to construct an object

 1. **object**
--
: an instance of some class; more generally, a location in memory containing data or functionality

 1. **setter**
--
: a kind of method that assigns data to an attribute

 1. **getter method**
--
: a kind of method that retrieves data stored in an attribute

 1. **`attr_writer`**
--
: an attribute for which a setter but not a getter is allowed

 1. **`attr_reader`**
--
: an attribute for which a getter but not a setter is allowed

 1. **`attr_accessor`**
--
: an attribute for which both setter and getter are allowed

<!--

https://github.com/nyc-bobolinks-2015/orange-tree-1-just-oranges-challenge/tree/ZINO_GUILLERMO/source

https://github.com/nyc-bobolinks-2015/ruby-drill-the-self-keyword-challenge/blob/Guillermo_Zino/source/self.rb

https://github.com/nyc-bobolinks-2015/design-drill-public-vs-private-interfaces-challenge/blob/Zino_Guillermo/source/bank_account.rb

https://github.com/nyc-bobolinks-2015/ruby-drill-accessor-methods-challenge/blob/Zino_AND_Guillermo/source/company_employee.rb

-->

---

class: center, middle

## END

    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>

<!-- From http://joshbode.github.io/remark/ansi.html#3, 20151229 -->
    <script src="http://gnab.github.io/remark/downloads/remark-latest.min.js"></script>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <script type="text/javascript">
      var hljs = remark.highlighter.engine;
    </script>
    <script src="terminal.language.js" type="text/javascript"></script>
    <script type="text/javascript">
      var slideshow = remark.create({
        highlightStyle: 'solarized_dark'
      });
      // extract the embedded styling from ansi spans
      $('code.terminal > span.hljs-ansi').replaceWith(function(i, x) {
        return x.replace(/<(\/?(\w+).*?)>/g, '<$1>')
      });
    </script>
  </body>
</html>
